#include "../include/my_str.h"


//!===========================================================================
//! Створення та знищення стрічки.
//!===========================================================================

/* Створити стрічку із буфером вказаного розміру. Пам'ять виділяється динамічно.
//! Варто виділяти buf_size+1 для спрощення роботи my_str_get_cstr().
//! УВАГА! Ця функція -- аналог конструктора інших мов.
//! Всі решта функцій можуть вважати, що їм не буде передано жодної змінної,
//! до якої не застосували рівно один раз цю функцію.
//! Тобто, до того, як викликати будь-яку іншу функцію, до змінної типу
//! my_str_t слід рівно один раз за час її існування викликати  my_str_create().
//! (З біллю в серці згадуються закони Мерфі -- кожне твердження
//! обов'язково зрозуміють неправильно. Розказавши 20-30 раз, вирішив
//! записати. Тепер очікую збільшення кількості скарг на довжину опису...)
//! Після використання -- викличте my_str_free().
//! Зауважте -- за такого підходу, повторний виклик my_str_create до тієї ж
//! змінної, без виклику my_str_free, вестиме до memory leak.
//! Повертає 0, якщо все ОК, від'ємні числа, якщо сталася помилка.*/
int my_str_create(my_str_t *str, size_t buf_size) {
    char *data_p;
    data_p = (char *) malloc(buf_size + 1);
    if (data_p == NULL) {
        return -1;
    }
    str->data = data_p;
    str->capacity_m = buf_size + 1;
    str->data[buf_size] = '\0';
    return 0;
}

/*  Створити стрічку із буфером вказаного розміру із переданої С-стрічки.
//! Якщо розмір, buf_size == 0, виділяє блок, рівний розміру С-стрічки, якщо
//! менший за її розмір -- вважати помилкою, не змінювати стрічку.
//! Пам'ять виділяється динамічно. Не слід викликати my_str_create(),
//! більше підійде my_str_resize() або my_str_reserve().
//! Коди завершення:
//! 0 -- якщо все ОК, -1 -- недостатній розмір буфера, -2 -- не вдалося виділити пам'ять*/
int my_str_from_cstr(my_str_t *str, const char *cstr, size_t buf_size) {
    if (buf_size + 1 < str->capacity_m) {
        return -1;  // недостатній розмір буфера
    } else {
        size_t block_len = char_arr_len(cstr);
        char *data_p = (char *) malloc(block_len + 1);
        if (!data_p) {
            return -2; // не вдалося виділити пам'ять
        }

        // copy char_arr to initialized memory
        data_p[block_len] = '\0';
        for (size_t i = 0; i < block_len; ++i) {
            data_p[i] = cstr[i];
        }

        str->data = data_p;
        str->size_m = block_len;
        str->capacity_m = block_len + 1;
        return 0;
    }
}

/*  Звільняє пам'ять, знищуючи стрічку.
//! Аналог деструктора інших мов.
//! Ремарка: free() нормально працює із NULL.*/
void my_str_free(my_str_t *str) {
    if (str)
        free(str->data);
//    str->capacity_m = 0;
//    str->size_m = 0;
    free(str);
}

//!============================================================================
//! Інформація про стрічку
//!============================================================================

/*  Повертає розмір стрічки.
//! Для нульового вказівника -- 0.*/
size_t my_str_size(const my_str_t *str) {
    if (str)
        return str->size_m;
    else
        return 0;
}

/*  Повертає розмір буфера.
//! Для нульового вказівника -- 0.*/
size_t my_str_capacity(const my_str_t *str) {
    if (str)
        return str->capacity_m;
    else
        return 0;
}

//! Повертає булеве значення, чи стрічка порожня:
int my_str_empty(const my_str_t *str) {
    if (str->size_m == 0)
        return 1;
    else
        return 0;
}

//!===========================================================================
//! Доступ до символів стрічки
//!===========================================================================

/*  Повертає символ у вказаній позиції, або -1, якщо вихід за межі стрічки,
//! включаючи переданий нульовий вказівник.
//! Тому, власне, int а не char*/
int my_str_getc(const my_str_t *str, size_t index) {
    if (index < 0 || index >= str->size_m || NULL == str || str->data == NULL) {
        return -1;
    } else {
        return (int) str->data[index];
    }
}

/* Записує символ у вказану позиції (заміняючи той, що там був),
//! Повертає 0, якщо позиція в межах стрічки,
//! Поветає -1, не змінюючи її вмісту, якщо ні.*/
int my_str_putc(my_str_t *str, size_t index, char c) {
    if (index < 0 || index >= str->size_m || NULL == str || str->data == NULL) {
        return -1;
    } else {
        str->data[index] = c;
        return 0;
    }
}

/*  Повернути вказівник на С-стрічку, еквівалентну str.
//! Вважатимемо, що змінювати цю С-стрічку заборонено.
//! Вважатимемо, що як тільки my_str_t змінено, цей вказівник
//! може стати некоректним.
//! Якщо в буфері було зарезервовано на байт більше за макс. розмір, можна
//! просто додати нульовий символ в кінці та повернути вказівник data.*/
const char *my_str_get_cstr(my_str_t *str) {
    if (str == NULL)
        return NULL;
    else
        return str->data;
}

//!===========================================================================
//! Модифікації стрічки, що змінюють її розмір і можуть викликати реалокацію.
//!===========================================================================
//! Якщо буфер недостатній -- ці функції збільшують його,
//! викликом my_str_reserve().
//! Розумним є буфер кожного разу збільшувати в 1.8-2 рази.
//! ==========================================================================

/*  Додає символ в кінець.
//! Повертає 0, якщо успішно,
//! -1 -- якщо передано нульовий вказівник,
//! -2 -- помилка виділення додаткової пам'яті.*/
int my_str_pushback(my_str_t *str, char c) {
    return 1;
}

/*  Викидає символ з кінця.
//! Повертає його, якщо успішно,
//! -1 -- якщо передано нульовий вказівник,
//! -2 -- якщо стрічка порожня.*/
int my_str_popback(my_str_t *str) {
    return 1;
}

/*  Копіює стрічку. Якщо reserve == true,
//! то із тим же розміром буферу, що й вихідна,
//! інакше -- із буфером мінімального достатнього розміру.
//! (Старий вміст стрічки перед тим звільняє, за потреби).
//! Повертає 0, якщо успішно, різні від'ємні числа для діагностики
//! проблеми некоректних аргументів.*/
int my_str_copy(const my_str_t *from, my_str_t *to, int reserve) {
    return 1;
}

/*  Очищає стрічку -- робить її порожньою. Складність має бути О(1).
//! Уточнення (чомусь ця ф-ція викликала багато непорозумінь):
//! стрічка продовжує існувати, буфер той самий, того ж розміру, що був,
//! лише містить 0 символів -- єдине, що вона робить, це size_m = 0.*/
void my_str_clear(my_str_t *str) {
    str->size_m = 0;
}

/*  Вставити символ у стрічку в заданій позиції, змістивши решту символів праворуч.
//! За потреби -- збільшує буфер.
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.*/
int my_str_insert_c(my_str_t *str, char c, size_t pos) {
    return 1;
}

/*  Вставити стрічку в заданій позиції, змістивши решту символів праворуч.
//! За потреби -- збільшує буфер.
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.*/
int my_str_insert(my_str_t *str, const my_str_t *from, size_t pos) {
    return 1;
}

/*  Вставити C-стрічку в заданій позиції, змістивши решту символів праворуч.
//! За потреби -- збільшує буфер.
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.*/
int my_str_insert_cstr(my_str_t *str, const char *from, size_t pos) {
    return 1;
}

/*  Додати стрічку в кінець.
//! За потреби -- збільшує буфер.
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.*/
int my_str_append(my_str_t *str, const my_str_t *from) {
    return 1;
}

/*  Додати С-стрічку в кінець.
//! За потреби -- збільшує буфер.
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.*/
int my_str_append_cstr(my_str_t *str, const char *from) {
    return 1;
}

/*  Скопіювати підстрічку, із beg включно, по end не включно ([beg, end)).
//! Якщо end за межами початкової стрічки -- це не помилка, копіювати всі
//! символи до кінця. beg має бути в її межах -- якщо beg>size, це помилка.
//! За потреби -- збільшує буфер.
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.*/
int my_str_substr(const my_str_t *from, my_str_t *to, size_t beg, size_t end) {
    return 1;
}

/*  C-string варіант my_str_substr().
//! Вважати, що в цільовій С-стрічці достатньо місц.*/
int my_str_substr_cstr(const my_str_t *from, char *to, size_t beg, size_t end) {
    return 1;
}

//!===========================================================================
//! Маніпуляції розміром стрічки
//!===========================================================================

//! Збільшує буфер стрічки, із збереженням вмісту,
//! якщо новий розмір більший за попередній,
//! не робить нічого, якщо менший або рівний.
//! (Як показує практика, це -- корисний підхід).
//! Для збільшення виділяє новий буфер, копіює вміст
//! стрічки (size_m символів -- немає сенсу копіювати
//! решту буфера) із старого буфера та звільняє його.
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.
int my_str_reserve(my_str_t *str, size_t buf_size) {
    if (buf_size + 1 < str->capacity_m) {
        if (my_str_realloc(str, buf_size) == -1)
            return -1;
    }
    return 0;
} // ???

//! Робить буфер розміром, рівний необхідному:
//! так, щоб capacity_m == size_t. Єдиний "офіційний"
//! спосіб зменшити фактичний розмір буфера.
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.
int my_str_shrink_to_fit(my_str_t *str) {
    if (str == NULL)
        return -1;

    if (str->size_m + 1 != str-> capacity_m) {
        if (my_str_realloc(str, str->size_m) == -1)
            return -2;
    }
    return 0;
}

//! Якщо new_size менший за поточний розмір -- просто
//! відкидає зайві символи (зменшуючи size_m). Якщо
//! більший -- збільшує фактичний розмір стрічки,
//! встановлюючи нові символи рівними sym.
//! За потреби, збільшує буфер.
//! Сподіваюся, різниця між розміром буфера та фактичним
//! розміром стрічки зрозуміла?
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.
int my_str_resize(my_str_t *str, size_t new_size, char sym) {
    return 1;
}

//!===========================================================================
//! Функції пошуку та порівняння
//!===========================================================================

//! Знайти першу підстрічку в стрічці, повернути номер її
//! початку або (size_t)(-1), якщо не знайдено. from -- місце, з якого починати шукати.
//! Якщо більше за розмір -- вважати, що не знайдено.
size_t my_str_find(const my_str_t *str, const my_str_t *tofind, size_t from) {
    if (NULL == str || tofind == NULL || str->size_m < tofind->size_m || from >= str->size_m || from < 0 ||
            tofind->size_m == 0)
        return (size_t) (-2);
//    if (tofind->size_m == 0)
//        return (size_t)(-1);

    size_t i = from, match = 0;
    while (i < str->size_m && match < tofind->size_m) {
        if (str->data[i] == tofind->data[match])
            match++;
        else
            match = 0;
        i++;
    }
    if (match == tofind->size_m)
        return i - match;
    else
        return (size_t)(-1);
}

//! Порівняти стрічки, повернути 0, якщо рівні (за вмістом!)
//! -1 (або інше від'ємне значення), якщо перша менша,
//! 1 (або інше додатне значення) -- якщо друга.
//! Поведінка має бути такою ж, як в strcmp.
int my_str_cmp(const my_str_t *str1, const my_str_t *str2) {
    if (str1->size_m > str2->size_m)
        return 1;
    else if (str1->size_m < str2->size_m)
        return -1;
    else {
        for (int j = 0; j < str1->size_m; ++j) {
            if (str1->data[j] != str2->data[j])
                return -1;
        }
        return 0;
    }
}

//! Порівняти стрічку із С-стрічкою, повернути 0, якщо рівні (за вмістом!)
//! -1 (або інше від'ємне значення), якщо перша менша,
//! 1 (або інше додатне значення) -- якщо друга.
//! Поведінка має бути такою ж, як в strcmp.
int my_str_cmp_cstr(const my_str_t *str1, const char *cstr2) {
    size_t str2_len = char_arr_len(cstr2);
    if (str1->size_m > str2_len)
        return 1;
    else if (str1->size_m < str2_len)
        return -1;
    else {
        for (int j = 0; j < str1->size_m; ++j) {
            if (str1->data[j] != cstr2[j])
                return -1;
        }
        return 0;
    }
}

//! Знайти перший символ в стрічці, повернути його номер
//! або (size_t)(-1), якщо не знайдено. from -- місце, з якого починати шукати.
//! Якщо більше за розмір -- вважати, що не знайдено.
size_t my_str_find_c(const my_str_t *str, char tofind, size_t from) {
    if (from > str->size_m)
        return -1;
    if (from < 0)
        from = 0;
//        exit(1);

    for (size_t j = from; j < str->size_m; ++j) {
        if(str->data[j] == tofind)
            return j;
    }
    return (size_t)(-1);
}

//! Знайти символ в стрічці, для якого передана
//! функція повернула true, повернути його номер
//! або (size_t)(-1), якщо не знайдено:
size_t my_str_find_if(const my_str_t *str, int (*predicat)(int)) {
    for (int j = 0; j < str->size_m; ++j) {
        if(predicat(str->data[j]))
            return j;
    }
    return (size_t)(-1);
}

//!===========================================================================
//! Ввід-вивід
//!===========================================================================

//! Прочитати стрічку із файлу. Читає цілий файл.
//! Не давайте читанню вийти за межі буфера! За потреби --
//! збільшуйте буфер.
//! Рекомендую скористатися fgets().
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.
int my_str_read_file(my_str_t *str, FILE *file) {
    return 1;
}

//! Аналог my_str_read_file, із stdin.
int my_str_read(my_str_t *str) {
    return 1;
}

//! Записати стрічку в файл:
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.
int my_str_write_file(const my_str_t *str, FILE *file) {
    return 1;
}

//! Записати стрічку на консоль:
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.
int my_str_write(const my_str_t *str, FILE *file) {
    return 1;
}

//! На відміну від my_str_read_file(), яка читає до кінця файлу,
//! читає по вказаний delimiter, за потреби
//! збільшує стрічку.
//! У випадку помилки повертає різні від'ємні числа, якщо все ОК -- 0.
int my_str_read_file_delim(my_str_t *str, FILE *file, char delimiter) {
    return 1;
}

size_t char_arr_len(const char *s) {
    size_t i = 0;
    while (*(s + i) != '\0') {
        i++;
    }
    return i;
}

void char_arr_copy(const char *arr, size_t to_index, char *arr_copy) {
    for (size_t j = 0; j < to_index; ++j) {
        arr_copy[j] = arr[j];
    }
}

int my_str_realloc(my_str_t *str, size_t buffer) {
    char *data_p = (char*)malloc(buffer + 1);

    if (data_p == NULL)
        return -1;

    if (str->size_m > buffer)
        str->size_m = buffer;

    char_arr_copy(str->data, str->size_m, data_p);
    data_p[buffer] = '\0';
    free(str->data);
    str->data = data_p;
    str->capacity_m = buffer + 1;
    return 0;
}
